<html>
<head>
<meta charset="utf-8">
<link href="https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400;1,700&family=Work+Sans:ital,wght@0,400;0,500;1,400;1,500&display=swap" rel="stylesheet">
<link rel="stylesheet" href="./article.css">
</head>
<body>
<canvas id="vis" width="200" height="200"></canvas>
<article>
<!--
<h1>
making a <b>TECHNO</b> track
<br>
from <strong>Scratch</strong>
</h1>

<p>In this article we will work our way to a viable <em>Techno</em> music track, using basic <strong>first principles</strong> and in the process we will learn about subjects like <em>acoustics</em> and <em>psychoacoustics</em>, <em>sound synthesis</em>, <em>rhythmic</em> and <em>harmonic</em> composition and arrangement, <em>mixing techniques</em> and we'll finally produce something that we can <em>dance to</em> and <em>enjoy!</em>
<br>
<br>
And all of this using just coding, and specifically, <strong>JavaScript</strong>.
Feeling intrigued yet? Follow me...</p>

<h2>The Kick</h2>

<p>Every good Techno track starts with a <strong>Kick</strong>. But what <em>is</em> a kick, <em>really?</em> According to Wikipedia:
</p>
<blockquote>
  The bass drum, or kick drum, is a large drum that produces a note of low definite or indefinite pitch
  <br>...<br>
  Bass drums are percussion instruments and vary in size and are used in several musical genres
  <br>...<br>
  In many forms of music, the bass drum is used to mark or keep time. The bass drum makes a low, boom sound when the mallet hits the drumhead.
</blockquote>
<p>
Ok, so what we get from this is that it's a kind of a <em>low-sounding</em> percussion instrument that is used to <em>keep time</em>. That last bit is particularly interesting, keeping time. What <em>is</em> time?</p>

<img src="./what-is-time.png">

<p>Besides being an illusion, you could also say that time is what it takes to get from place A to place B. And how do we get there? We walk! One foot after another. Applying a bit of Aristotelian logic, if thing A can do X and thing B can do the same X, then thing A can possibly be represented by thing B. So, if feet track time, and kicks track time, then feet must be for kicks. And vice versa. So, the kick sound is represented by our feet. Makes sense, that's why it's called a <em>kick</em>. But not only that, actually all sounds are represented on our body. Low frequency sounds like kicks and bass map to the lower part of our body, and higher frequency sounds like snares, hihats and most of the instruments map to our upper body.
</p>
<p>
Ugghh, enough geeking! Let's listen to the damn kick. Click on play:
</p>-->
<!-- <pre><code title="techno-tutorial/kick-simple.js" type="shot" bpm="60">
export default c =>
  Math.sin(440 * 2 * Math.PI * c.s)
</code></pre>
 -->
<pre><code title="techno-tutorial/kick-simple.js" type="shot">
export default c =>
  Math.sin(110 * Math.exp(-c.t * 15))
</code></pre>
<!--<p>
digital audio..
sampling..
fourier transform..
wave shape,
sine wave,
exponent,
time
applying filters..
ears as math processors..-->
<pre><code title="techno-tutorial/kick.js" type="shot">
export default (c, {
  phase = 1.822,
  punch = 105,
  speed = 12.8
} = {}) =>
  Math.sin(
    phase
  + punch
  * Math.exp(-c.t * speed)
  ) * (1-Math.min(1, c.t*8.5))
</code></pre>

<pre><code title="techno-tutorial/hihat-inline-hp.js" type="shot">
export default c => c(
  c => Math.sin(Math.random() * Math.exp(-c.t*10)),
  async c => {
    let xm1 = 0
    let x = 0
    let y = 0
    return (c, { a = .5 }) => {
      x = +c.input
      y = (y + x - xm1) * a
      xm1 = x
      return y
    }
  }
)
</code></pre>

<pre><code title="techno-tutorial/highpass.js" type="shot">
export default async c => {
  let xm1 = 0
  let x = 0
  let y = 0
  return (c, { a = .5 }) => {
    x = +c.input
    y = (y + x - xm1) * a
    xm1 = x
    return y
  }
}
</code></pre>

<pre><code title="techno-tutorial/lowpass.js" type="shot">
export default async c => {
  let y = 0
  return (c, { a = .5 }) =>
    y += (c.input - y) * a
}
</code></pre>

<pre><code title="techno-tutorial/hihat-mixed.js" type="shot">
import Highpass from './highpass.js'
export default c => c(
  c => Math.sin(Math.random() * Math.exp(-c.t*10)),
  async c => {
    const hp = await Highpass(c)
    return c => hp(c, { a: .5 * Math.exp(-c.t*10) })
  }
)
</code></pre>

<pre><code title="techno-tutorial/envelope.js" type="shot">
export default (c, { decay = 10 }) =>
  Math.exp(-c.k * decay)
</code></pre>

<pre><code title="techno-tutorial/hihat.js" type="shot">
import envelope from './envelope.js'
import Highpass from './highpass.js'
export default c => c(
  c => Math.sin(Math.random() * envelope(c, { decay: 8 })),
  async c => {
    const hp = await Highpass(c)
    return c => hp(c, { a: .5 * envelope(c, { decay: 8 }) })
  }
)
</code></pre>
<!--
<pre><code title="techno-tutorial/kick-import.js" type="shot">
import kick from './kick.js'
export default c => kick(c)
</code></pre>
 -->
<!-- <pre><code title="techno-tutorial/kick-loop-buffer.js" type="loop">
export default async c => {
  const kick = c.render('kick.js')
  return t => kick(t)
}
</code></pre>
 -->
<pre><code title="techno-tutorial/saw.js" type="loop">
export default (c, { freq = 50 }) =>
  1 - 2 * (c.s % (1 / freq)) * freq
</code></pre>

<pre><code title="techno-tutorial/saw-melody.js" type="loop">
import saw from './saw.js'
export default (c, {
  melody = [
    50, 50, 71, 60,
    50, 50, 90, 60,
  ]
} = {}) =>
  saw(c, { freq: melody[c.b % melody.length|0] })
</code></pre>

<pre><code title="techno-tutorial/bass.js" type="loop" bpm="135">
import Lowpass from './lowpass.js'
export default (c, { a = .5 }) => c(
  c => c.src('./saw-melody.js'),
  async c => {
    const lp = await Lowpass(c)
    return c => lp(c, { a: a + ((a-.002)
    * Math.sin(3.15+(1/8)*c.b*Math.PI*2)
    * Math.sin(3.14+(3/2)*c.b*Math.PI*2)
    ) })*.4
  }
)
</code></pre>

<!--
<pre><code title="techno-tutorial/bass.js" type="loop">
import osc from './saw-melody.js'
export default async c => {
  const filter = c.RingBuffer('filter', 2)

  // lowpass cutoff coefficient generator
  const lowpass = (
    hz,
    dt = 1 / c.sampleRate,
    rc = 1 / (hz * 2 * Math.PI)
  ) => dt / (rc + dt)

  // lowpass filter cutoff frequency
  return mix => mix(
    t => osc(t, { melody: [50, 50, 70, 60] }) * .55,

    // lowpass filter
    (t, {
      cutoff = 300, // lowpass cutoff frequency
      lfoSpeed = 2/3, // lfo speed
      lfoAmount = cutoff - 50, // lfo amount
      lfoPhase = 3.3 // lfo phase
    } = {}) =>
      filter[0] += (t.input - filter[0])
    * lowpass(
        cutoff
      + lfoAmount
      * Math.sin(lfoPhase + lfoSpeed * t.k * Math.PI * 2)
    ),

    // envelope
    t => t.input *
      ( Math.min(1, (t.k%(1/2)) * 20) // attack
      - Math.min(1, (t.k%(1/2)) * 2) // decay
      ),
  )
}
</code></pre>
 -->
<pre><code title="techno-tutorial/mix-buffers.js" type="loop" bpm="135">
export default c => c(
  c => c.new({len:c.br*4,ch:1},
    c => c.src('./bass.js',{a:.02}),
  ),
  c => c.new({len:c.br/2,ch:1},
    c => c.src('./hihat.js',{n:0}),
  ),
  c => c.new({len:c.br,ch:1},
    c => c.src('./kick.js',{n:0}),
  ),
)
</code></pre>

<pre><code title="techno-tutorial/mix-buffers-auto.js" type="loop" bpm="135">
export default c => c(
  c => c.new({len:c.br*4,ch:1},
    c => c.src('./bass.js',{a:.05}),//,{melody:[50,0]}),
    c => c.input * 2
  ),
  c => c.new({len:c.br/([1,2,3,4][Math.random()*4|0]),ch:1},
    c => c.src('./hihat.js',{n:0}),
  ),
  c => c.new({len:c.br*([1,3/2,.5][Math.random()*3|0]),ch:1},
    c => c.src('./kick.js',{n:0}),
    c => c.input * 4
  ),
)
</code></pre>
<!--
<pre><code title="techno-tutorial/mix-breaks.js" type="loop">
export default async c => {
  const bass = c.render('bass.js')
  const kick = c.render('kick.js')
  return t =>
    bass(t, { size: c.beatRate*(t.k/4%3<2?3/2:4) })*4
  + kick(t, { size: c.beatRate*(t.k/4%8<7?1:3/2) })*6
}
</code></pre>
 -->
</article>
<script type="module">
import Editor, { registerEvents } from './src/editor.js'
import LoopNode from './vendor/dsp/src/loop-node.js'
import ShotNode from './vendor/dsp/src/shot-node.js'
import Mix from './vendor/dsp/src/mix.js'
import mixWorker from './vendor/dsp/src/mix-worker-service.js'
import DynamicCache from './vendor/dsp/dynamic-cache.js'
import toFinite from './lib/to-finite.js'
import Audio from './audio.js'
import atomic from './vendor/dsp/lib/atomic.js'
import Shared32Array from './vendor/dsp/lib/shared-array-buffer.js'

const app = {}

const scheduleUpdate = new Set

const main = async () => {
  await DynamicCache.install()
  const cache = window.__cache = new DynamicCache('article', { 'Content-Type': 'application/javascript' })

  let playingWidget

  const widgets = []

  mixWorker.onerror = (error, url) => {
    console.error(error, url)
    if (playingWidget) {
      playingWidget.errors.textContent = error.stack
    }
  }

  cache.onchange = url => {
    scheduleUpdate.add(url)
    widgets.forEach(async widget => {
      if (widget.node?.playing) {
        await widget.render()
      }
    })
    ;[...document.querySelectorAll('.errors')]
      .forEach(el => el.textContent = '')
  }

  const PlayNode = {
    'loop': LoopNode,
    'shot': ShotNode
  }

  const PlayIcon = {
    'loop': 'âŸ²',
    'shot': 'â–¶',
    'playing': 'ð„¥'
  }

  ;[...document.querySelectorAll('code')].forEach(
    (node, i) => {
      const widget = {}

      widgets.push(widget)

      const type = widget.type = node.getAttribute('type')
      const bpm = widget.bpm = toFinite(+node.getAttribute('bpm')) || 60

      const editor = widget.editor = new Editor({
        id: i,
        title: node.title,
        value: node.textContent.trim(),
        fontSize: '11.5pt',
        width: 620,
        height: 1,
        padding: 10,
        autoResize: true,
        pseudoWorker: true,
        cache
      })

      const div = document.createElement('div')
      div.className = 'editor'
      div.appendChild(editor.canvas)

      const play = document.createElement('div')
      play.className = 'play ' + type
      play.textContent = PlayIcon[type]
      play.style.zIndex = '1000'
      div.appendChild(play)

      const errors = document.createElement('div')
      errors.className = 'errors'
      div.appendChild(errors)

      widget.errors = errors

      play.onmousedown = async () => {
        widget.n = 0

        const audio = Audio()

        const stop = () => {
          playingWidget = null
          try {
            widget.node.stop(0)
          } catch {}
          play.classList.remove('playing')
          play.textContent = PlayIcon[type]
          mixWorker.clear()
        }

        if (playingWidget) {
          return stop()
        }

        if (widget.type === 'loop') {
          playingWidget = widget
          play.classList.add('playing')
          play.textContent = PlayIcon['playing']
        }

        if (!widget.node) {
          const node = widget.node = new PlayNode[type]
          node.setBpm(widget.bpm)
          node.connect(audio.gain)

          const size = node.bufferSize
          const buffer = widget.buffer = [
            new Shared32Array(size),
            new Shared32Array(size)
          ]

          const context = {
            url: editor.filename,
            bpm: node.bpm,
            beatRate: node.beatRate,
            sampleRate: node.sampleRate,
            buffer,
          }

          const fn = widget.fn = c => c.src(editor.filename)

          const mix = widget.mix = Mix(context)
          node.onbar = async () => {
            widget.n += widget.buffer[0].length
            widget.render()
          }
        }

        widget.render = atomic(async () => {
          if (scheduleUpdate.size > 0) {
            for (const url of scheduleUpdate) {
              mixWorker.update(url)
            }
            scheduleUpdate.clear()
          }
          const time = performance.now()
          try {
            await widget.mix(widget.fn, { n: widget.n })
            if (!widget.node.playing) return
          } catch (error) {
            errors.textContent = error.stack
            console.error(error)
            return
          }
          const diff = performance.now() - time
          console.log('time to render:', diff)
          if (diff > 1000) console.warn('Too slow!', (diff/1000).toFixed(1) + 's' )
          widget.node.playBuffer(widget.buffer)
          draw(widget.buffer[0])
        }, { recentOnly: true, timeout: 2000 })

        try {
          await widget.mix(widget.fn, { n: widget.n })
          if (type === 'loop' && !playingWidget) return
        } catch (error) {
          errors.textContent = error.stack
          console.error('thrown error', error)
          return
        }

        if (type === 'shot') {
          if (scheduleUpdate.size > 0) {
            for (const url of scheduleUpdate) {
              mixWorker.update(url)
              console.log('updating', url)
            }
            scheduleUpdate.clear()
          }
          widget.node.setBuffer(widget.buffer)
          widget.node.start()
        } else {
          widget.node.resetTime?.(-3)
          widget.node.start()
          widget.node.playBuffer(widget.buffer)
        }
        draw(widget.buffer[0])
      }

      node.parentNode.replaceChild(div, node)

      editor.onresize()
      setInterval(() => editor.onresize(), 1000)
    })

  scheduleUpdate.clear()

  registerEvents(document.body)
}

const draw = (data) => {
  const canvas = document.getElementById('vis')
  const ctx = canvas.getContext('2d')
  const width = canvas.width*2*window.devicePixelRatio
  const height = canvas.height/2
  ctx.clearRect(0, 0, width, height)
  ctx.globalCompositeOperation = 'source-over'
  ctx.fillStyle = 'rgba(0,0,0,.5)' //'#99ff00'
  ctx.fillRect(0, 0, width, height) //*2, height*2)
  // ctx.strokeStyle = '#a6e22e' //'#568208' //'#99ff00'
  const color = 'rgba(215,255,105,0.46)'
  const peak = '#f31'
  ctx.lineWidth = .5
  ctx.globalCompositeOperation = 'lighter'
  ctx.beginPath()
  const y = height
  const h = height / 2
  const s = 32
  ctx.moveTo(0, h)
  const w = Math.floor(data.length / width)
  for (let x = 0; x < width; x++) {
    ctx.beginPath()

    let max = Math.abs(Math.max(...data.subarray(x*w, x*w+w)))
    if (max > 1) {
      ctx.strokeStyle = peak
      max = 1
    }
    else ctx.strokeStyle = color
    ctx.moveTo(x/2/2, (h - (max * h)))
    ctx.lineTo(x/2/2, h) //(h + (max * h)))
    ctx.stroke()

    let min = Math.abs(Math.min(...data.subarray(x*w, x*w+w)))
    if (min > 1) {
      ctx.strokeStyle = peak
      min = 1
    }
    else ctx.strokeStyle = color
    ctx.moveTo(x/2/2, h)
    ctx.lineTo(x/2/2, (h + (min * h)))
    ctx.stroke()

    // let sum = 0
    // for (let i = x*w; i < x*w+w; i += s) {
    //   sum += Math.abs(wave[i])
    // }
    // let avg = Math.min(1, (sum / (w / s) )) * h

  }
  ctx.lineTo(width, h)
  ctx.stroke()
}

main()
</script>
</body>
</html>