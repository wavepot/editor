<html>
<head>
<meta charset="utf-8">
<link href="https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400;1,700&family=Work+Sans:ital,wght@0,400;0,500;1,400;1,500&display=swap" rel="stylesheet">
<link rel="stylesheet" href="./article.css">
</head>
<body>
<div id="vis">
<canvas id="waveform" width="400" height="300"></canvas>
<canvas id="spectrogram" width="400" height="300"></canvas>
<canvas id="frequency" width="400" height="300"></canvas>
</div>
<article>
<!--
<h1>
making a <b>TECHNO</b> track
<br>
from <strong>Scratch</strong>
</h1>

<p>In this article we will work our way to a viable <em>Techno</em> music track, using basic <strong>first principles</strong> and in the process we will learn about subjects like <em>acoustics</em> and <em>psychoacoustics</em>, <em>sound synthesis</em>, <em>rhythmic</em> and <em>harmonic</em> composition and arrangement, <em>mixing techniques</em> and we'll finally produce something that we can <em>dance to</em> and <em>enjoy!</em>
<br>
<br>
And all of this using just coding, and specifically, <strong>JavaScript</strong>.
Feeling intrigued yet? Follow me...</p>

<h2>The Kick</h2>

<p>Every good Techno track starts with a <strong>Kick</strong>. But what <em>is</em> a kick, <em>really?</em> According to Wikipedia:
</p>
<blockquote>
  The bass drum, or kick drum, is a large drum that produces a note of low definite or indefinite pitch
  <br>...<br>
  Bass drums are percussion instruments and vary in size and are used in several musical genres
  <br>...<br>
  In many forms of music, the bass drum is used to mark or keep time. The bass drum makes a low, boom sound when the mallet hits the drumhead.
</blockquote>
<p>
Ok, so what we get from this is that it's a kind of a <em>low-sounding</em> percussion instrument that is used to <em>keep time</em>. That last bit is particularly interesting, keeping time. What <em>is</em> time?</p>

<img src="./what-is-time.png">

<p>Besides being an illusion, you could also say that time is what it takes to get from place A to place B. And how do we get there? We walk! One foot after another. Applying a bit of Aristotelian logic, if thing A can do X and thing B can do the same X, then thing A can possibly be represented by thing B. So, if feet track time, and kicks track time, then feet must be for kicks. And vice versa. So, the kick sound is represented by our feet. Makes sense, that's why it's called a <em>kick</em>. But not only that, actually all sounds are represented on our body. Low frequency sounds like kicks and bass map to the lower part of our body, and higher frequency sounds like snares, hihats and most of the instruments map to our upper body.
</p>
<p>
Ugghh, enough geeking! Let's listen to the damn kick. Click on play:
</p>-->
<!--
<pre><code title="techno-tutorial/lowpassxx.js" type="shot">
export default c => +c.x
</code></pre>
 -->

<pre><code title="techno-tutorial/saw.js" type="shot">
export default (c, { freq = 50, ig = 's' }) =>
  1 - 2 * (c[ig] % (1 / freq)) * freq
</code></pre>

<pre><code title="techno-tutorial/sin.js" type="shot">
export default (c, { freq = 50, ig = 's' }) =>
  Math.sin(freq * c[ig] * Math.PI * 2)
</code></pre>

<pre><code title="techno-tutorial/tone.js" type="shot">
export default c =>
  (c.s < .5 ? Math.sin(50 * 2 * Math.PI * c.s) : 0)*.3
+ (c.s < .5 ? Math.sin(3000 * 2 * Math.PI * c.s) : 0)*.3
+ (c.s < .5 ? Math.sin(10000 * 2 * Math.PI * c.s) : 0)*.3
+ (c.s < .5 ? Math.sin(20000 * 2 * Math.PI * c.s) : 0)*.3
</code></pre>

<pre><code title="techno-tutorial/saw-melody.js" type="shot">
import saw from './saw.js'
export default (c, {
  melody = [
    50, 50, 71, 60,
    50, 50, 90, 60,
  ]
} = {}) =>
  saw(c, { freq: melody[c.b % melody.length|0] })
</code></pre>

<pre><code title="techno-tutorial/saw-melody-wavetable.js" type="loop">
import Saw from './saw-wavetable.js'
export default async c => {
  const saw = await Saw(c)
  return (c, {
    melody=[
      50, 50, 71, 60,
      50, 50, 90, 60,
    ]
  }=c) =>
    saw(c, {freq:melody[c.b % melody.length|0]}) }
</code></pre>

<pre><code title="techno-tutorial/wavetable.js" type="loop" bpm="150">
export default async (c, {
  osc='./saw.js',
  len=1024,
  sync='sr',
  alias=false
}=c) => {
  let coeff = len/c[sync]
  let pos = 0.0
  let index = 0
  let alpha = 0.0
  let next = 0.0
  let curr = 0.0
  let buffer = await c.buf({len,ch:1})
  let table = (await c.src(osc,{
    n:0,
    buffer,
    ig:sync[0],
    freq:c[sync]/len
  }))[0]
  if (alias) {
    return (c,{freq=64}=c) => {
      pos = (c.n*freq*coeff)%len
      index = Math.floor(pos)
      alpha = pos-index
      next = table[index+1]??table[0]
      curr = table[index]
      return curr+(next-curr)*alpha
    }
  } else {
    return (c,{freq=64}=c) => {
      pos = (c.n*freq*coeff)%len
      index = Math.floor(pos)
      return table[index]
    }
  }
}
</code></pre>

<pre><code title="techno-tutorial/saw-wavetable.js" type="shot">
export default async (c, {
  len=1024,
  alias=true
}=c) => {
  let coeff = len/c.sr
  let pos = 0.0
  let index = 0
  let alpha = 0.0
  let next = 0.0
  let curr = 0.0
  let buffer = await c.buf({len,ch:1})
  let table = (await c.src('./saw.js',{
    n:0,
    buffer,
    freq:c.sr/len
  }))[0]
  return (c,{freq=64}={}) => {
    pos += freq*coeff
    if (pos > len) pos -= len
    index = pos|0
    if (!alias) return table[index]??0
    alpha = pos-index
    next = table[index+1]??table[0]??0
    curr = table[index]??0
    return curr+(next-curr)*alpha
  }
}
</code></pre>

<pre><code title="techno-tutorial/mix-buffers-auto.js" type="shot" bpm="135">
export default c => c(
  c => c.new({len:c.br*4,ch:1},
    c => c.src('./bass.js',{a:.05}),//,{melody:[50,0]}),
    c => c.x * 2
  ),
  c => c.new({len:c.br/([1,2,3,4][Math.random()*4|0]),ch:1},
    c => c.src('./hihat.js',{n:0}),
  ),
  c => c.new({len:c.br*([1,3/2,.5][Math.random()*3|0]),ch:1},
    c => c.src('./kick.js',{n:0}),
    c => c.x * 4
  ),
)
</code></pre>

<pre><code title="techno-tutorial/lowpass.js" type="shot">
export default async c => {
  let y = 0
  return (c, { a = .5 }) =>
    y += (c.x - y) * a
}
</code></pre>

<pre><code title="techno-tutorial/highpass.js" type="shot">
export default async c => {
  let xm1 = 0
  let x = 0
  let y = 0
  return (c, { a = .5 }) => {
    x = +c.x
    y = (y + x - xm1) * a
    xm1 = x
    return y
  }
}
</code></pre>

<pre><code title="techno-tutorial/kick-simple.js" type="shot">
export default c =>
  Math.sin(110 * Math.exp(-c.t * 15))
</code></pre>
<!--<p>
digital audio..
sampling..
fourier transform..
wave shape,
sine wave,
exponent,
time
applying filters..
ears as math processors..-->
<pre><code title="techno-tutorial/kick.js" type="shot">
export default (c, {
  phase = 1.822,
  punch = 105,
  speed = 12.8
} = {}) =>
  Math.sin(
    phase
  + punch
  * Math.exp(-c.t * speed)
  ) * (1-Math.min(1, c.t*8.5))
</code></pre>

<pre><code title="techno-tutorial/hihat-inline-hp.js" type="shot">
export default c => c(
  c => Math.sin(Math.random() * Math.exp(-c.t*10)),
  async c => {
    let xm1 = 0
    let x = 0
    let y = 0
    return (c, { a = .5 }) => {
      x = +c.x
      y = (y + x - xm1) * a
      xm1 = x
      return y
    }
  }
)
</code></pre>

<pre><code title="techno-tutorial/highpass.js" type="shot">
export default async c => {
  let xm1 = 0
  let x = 0
  let y = 0
  return (c, { a = .5 }) => {
    x = +c.x
    y = (y + x - xm1) * a
    xm1 = x
    return y
  }
}
</code></pre>

<pre><code title="techno-tutorial/hihat-mixed.js" type="shot">
import Highpass from './highpass.js'
export default c => c(
  c => Math.sin(Math.random() * Math.exp(-c.t*10)),
  async c => {
    const hp = await Highpass(c)
    return c => hp(c, { a: .5 * Math.exp(-c.t*10) })
  }
)
</code></pre>

<pre><code title="techno-tutorial/envelope.js" type="shot">
export default (c, { decay = 10 }) =>
  Math.exp(-c.k * decay)
</code></pre>

<pre><code title="techno-tutorial/hihat.js" type="shot">
import envelope from './envelope.js'
import Highpass from './highpass.js'
export default (c, {decay=8,a=.5}) => c(
  c => Math.sin(Math.random() * envelope(c, { decay })),
  async c => {
    const hp = await Highpass(c)
    return c => hp(c, { a: a * envelope(c, { decay }) })
  }
)
</code></pre>
<!--
<pre><code title="techno-tutorial/kick-import.js" type="shot">
import kick from './kick.js'
export default c => kick(c)
</code></pre>
 -->
<!-- <pre><code title="techno-tutorial/kick-loop-buffer.js" type="loop">
export default async c => {
  const kick = c.render('kick.js')
  return t => kick(t)
}
</code></pre>
 -->
<pre><code title="techno-tutorial/piano.js" type="loop" bpm="135">
import envelope from './envelope.js'
import Wave from './wavetable.js'
const harm = [
  // 0.700, 0.243, 0.229, 0.095, 0.139, 0.087, 0.288, 0.199, 0.124, 0.090,
  0.700, 0.043, 0.829, 0.095, 0.739, 0.487, 0.088, 0.599, 0.024, 0.790,
]
export default async c => {
  const tonic = await Wave(c, {osc:'./sin.js'})
  const sins = await Promise.all(
    harm.map(() => Wave(c, {osc:'./sin.js'})))
  let x = 0
  let hz = 0
  return (c, {
    melody=[
      50, 50, 71, 60,
      50, 50, 90, 60,
    ]
  }=c) => {
    x = 0
    hz = melody[c.b % melody.length|0]
    x += tonic(c, { freq: hz })
    for (let i = 1; i <= harm.length; i++) {
      x += sins[i-1](c, { freq: hz*i*harm[i-1] })
    }
    return x/harm.length
  }
}
</code></pre>



<pre><code title="techno-tutorial/bass.js" type="loop" bpm="135">
import Wave from './wavetable.js'
import Lowpass from './lowpass.js'
export default async (c, { a = .5 }=c) => {
  const lfo1 = await Wave(c, {osc:'./sin.js'})
  const lfo2 = await Wave(c, {osc:'./sin.js'})

  return c => c(
    c => c.src('./saw-melody-wavetable.js'),
    async c => {
      const lp = await Lowpass(c)
      return c => lp(c, { a: a + ((a-.002)
      * lfo1(c, {freq:3.15+(1/8)})
      * lfo2(c, {freq:3.14+(3/2)})
      ) })*.4
    }
  )
}
</code></pre>

<!--
<pre><code title="techno-tutorial/bass.js" type="loop">
import osc from './saw-melody.js'
export default async c => {
  const filter = c.RingBuffer('filter', 2)

  // lowpass cutoff coefficient generator
  const lowpass = (
    hz,
    dt = 1 / c.sampleRate,
    rc = 1 / (hz * 2 * Math.PI)
  ) => dt / (rc + dt)

  // lowpass filter cutoff frequency
  return mix => mix(
    t => osc(t, { melody: [50, 50, 70, 60] }) * .55,

    // lowpass filter
    (t, {
      cutoff = 300, // lowpass cutoff frequency
      lfoSpeed = 2/3, // lfo speed
      lfoAmount = cutoff - 50, // lfo amount
      lfoPhase = 3.3 // lfo phase
    } = {}) =>
      filter[0] += (t.input - filter[0])
    * lowpass(
        cutoff
      + lfoAmount
      * Math.sin(lfoPhase + lfoSpeed * t.k * Math.PI * 2)
    ),

    // envelope
    t => t.input *
      ( Math.min(1, (t.k%(1/2)) * 20) // attack
      - Math.min(1, (t.k%(1/2)) * 2) // decay
      ),
  )
}
</code></pre>
 -->
<pre><code title="techno-tutorial/mix-buffers.js" type="loop" bpm="135">
export default async c => {
  // const bass = await c.src('./bass.js',{a:.02,
  const bassBuffer = await c.buf({id:'bass',len:c.br*4,ch:1})

  const hihat = await c.src('./hihat.js',{n:0,
    buffer: await c.buf({id:'hihat',len:c.br,ch:1})})

  const kick = await c.src('./kick.js',{n:0,
    buffer: await c.buf({id:'kick',len:c.br,ch:1})})

  return async c => {
    const bass = await c.src('./bass.js',{a:.22,
      buffer: bassBuffer})

    c.mix(c.zero(c.buffer),
      hihat,
      kick,
      bass
    )
  }
}
</code></pre>


<pre><code title="techno-tutorial/mix-buffers.js-2" type="loop" bpm="135">
export default async c => {
  const bassBuffer = await c.buf({id:'bass',len:c.br*4,ch:1})

  const hihat = await c.src('./hihat.js',{n:0,a:.05,
    decay: .5,
    buffer: await c.buf({id:'hihat',len:c.br*2,ch:1})})

  const kick = await c.src('./kick.js',{n:0,
    buffer: await c.buf({id:'kick',len:c.br*2,ch:1})})

  return async c => {
    const bass = await c.src('./bass.js',{a:.56,
      len:64,alias:true,
      melody:[30,30*11/7],
      buffer: bassBuffer})

    c.mix(c.zero(c.buffer),
      [hihat,1/2],
      // [kick,4/4],
      [bass,3/4],
    )
  }
}
</code></pre>

<pre><code title="techno-tutorial/mix-piano.js" type="loop" bpm="135">
import Piano from './piano.js'

export default async c => {
  const bassBuffer = await c.buf({id:'bass',len:c.br*4,ch:1})

  const chord = await Promise.all([1,2,3].map(
    () => Piano(c)))

  const hihat = await c.src('./hihat.js',{n:0,a:.05,
    decay: 3.5,
    buffer: await c.buf({id:'hihat',len:c.br*2,ch:1})})

  const kick = await c.src('./kick.js',{n:0,
    buffer: await c.buf({id:'kick',len:c.br*2,ch:1})})

  const Notes = [120,140,160]

  let notes = Notes.map(n => n*3.29)

  return c => c(
    c => { c.zero(c.buffer) },
    async c => async c => {
      const bass = await c.src('./bass.js',{a:.02,
        len:64,alias:true,
        melody:[50,50*11/7],
        buffer: bassBuffer})

      c.mix(c.buffer,
        [hihat,1/4],
        [kick,2/4],
        [bass,3/4],
      )
    },
    // c => { notes = Notes.map(n => n*Math.random()*5) },
    c => c.x
    + (chord[0](c, { melody: [notes[0]] })*.2
    + chord[1](c, { melody: [notes[1]] })*.14
    + chord[2](c, { melody: [notes[2]] })*.17)
    * [c.k<2.75
      ?Math.exp(-((c.k+.34)%1) * 6.3)
      :Math.exp(-((c.k+.34)%1/2) * 3)]
  )
}
</code></pre>

<pre><code title="techno-tutorial/mix-piano-2.js" type="loop" bpm="135">
import Piano from './piano.js'

export default async c => {
  const [bass,hihat,kick] = await Promise.all([
    c.buf({id:'bass',len:c.br*8,ch:1}),
    c.buf({id:'hihat',len:c.br*2,ch:1}),
    c.buf({id:'kick',len:c.br*2,ch:1}),
  ])
  await Promise.all([
    c.src('./bass.js',{buffer:bass,
      a:.22,
      len:64,
      alias:false,
      melody:[50,50*11/7],
    }),
    c.src('./hihat.js',{buffer:hihat,
      a:.05,
      decay:3.5
    }),
    c.src('./kick.js',{buffer:kick,
      a:.05,
      decay:3.5
    }),
  ])
  return c => c(
    c => { c.zero(c.buffer) },
    c => {
      c.mix(c.buffer,
        [hihat,1/2],
        [kick,2/4],
        [bass,3/4],
      )
    },
    async c => {
      const chord = await Promise.all(
        [1,2,3].map(() => Piano(c)))

      const Notes = [120,140,160]
      const notes = Notes.map(n => n*3.29)

    // c => { notes = Notes.map(n => n*Math.random()*5) },
      return c => c.x
        + (chord[0](c, { melody: [notes[0]] })*.2
        + chord[1](c, { melody: [notes[1]] })*.14
        + chord[2](c, { melody: [notes[2]] })*.17)
        * [c.k<2.75
          ?Math.exp(-((c.k+.34)%1) * 6.3)
          :Math.exp(-((c.k+.34)%1/2) * 3)]
    }
  )
}
</code></pre>
<!--
<pre><code title="techno-tutorial/mix-breaks.js" type="loop">
export default async c => {
  const bass = c.render('bass.js')
  const kick = c.render('kick.js')
  return t =>
    bass(t, { size: c.beatRate*(t.k/4%3<2?3/2:4) })*4
  + kick(t, { size: c.beatRate*(t.k/4%8<7?1:3/2) })*6
}
</code></pre>
 -->
</article>
<script type="module">
import Editor, { registerEvents } from './src/editor.js'
import LoopNode from './vendor/dsp/src/loop-node.js'
import ShotNode from './vendor/dsp/src/shot-node.js'
import Mix from './vendor/dsp/src/mix.js'
import mixWorker from './vendor/dsp/src/mix-worker-service.js'
import DynamicCache from './vendor/dsp/dynamic-cache.js'
import toFinite from './lib/to-finite.js'
import Audio from './audio.js'
import atomic from './vendor/dsp/lib/atomic.js'
import Shared32Array from './vendor/dsp/lib/shared-array-buffer.js'

const app = {}

const scheduleUpdate = new Set

const main = async () => {
  await DynamicCache.install()
  const cache = window.__cache = new DynamicCache('article', { 'Content-Type': 'application/javascript' })

  let playingWidget

  const widgets = []

  mixWorker.onerror = (error, url) => {
    console.error(error, url)
    if (playingWidget) {
      playingWidget.errors.textContent = error.stack
    }
  }

  cache.onchange = url => {
    scheduleUpdate.add(url)
    widgets.forEach(async widget => {
      if (widget.node?.playing) {
        await widget.render()
      }
    })
    ;[...document.querySelectorAll('.errors')]
      .forEach(el => el.textContent = '')
  }

  const PlayNode = {
    'loop': LoopNode,
    'shot': ShotNode
  }

  const PlayIcon = {
    'loop': 'âŸ²',
    'shot': 'â–¶',
    'playing': 'ð„¥'
  }

  ;[...document.querySelectorAll('code')].forEach(
    (node, i) => {
      const widget = {}

      widgets.push(widget)

      const type = widget.type = node.getAttribute('type')
      const bpm = widget.bpm = toFinite(+node.getAttribute('bpm')) || 60

      const editor = widget.editor = new Editor({
        id: i,
        title: node.title,
        value: node.textContent.trim(),
        fontSize: '11.5pt',
        width: 620,
        height: 1,
        padding: 10,
        autoResize: true,
        pseudoWorker: true,
        cache
      })

      const div = document.createElement('div')
      div.className = 'editor'
      div.appendChild(editor.canvas)

      const play = document.createElement('div')
      play.className = 'play ' + type
      play.textContent = PlayIcon[type]
      play.style.zIndex = '1000'
      div.appendChild(play)

      const errors = document.createElement('div')
      errors.className = 'errors'
      div.appendChild(errors)

      widget.errors = errors

      play.onmousedown = async () => {
        widget.n = 0

        const audio = Audio()

        const stop = () => {
          playingWidget = null
          try {
            widget.node.stop(0)
          } catch {}
          play.classList.remove('playing')
          play.textContent = PlayIcon[type]
          mixWorker.clear()
        }

        if (playingWidget) {
          return stop()
        }

        if (widget.type === 'loop') {
          playingWidget = widget
          play.classList.add('playing')
          play.textContent = PlayIcon['playing']
        }

        if (!widget.node) {
          const node = widget.node = new PlayNode[type]
          node.setBpm(widget.bpm)
          node.connect(audio.gain)

          const size = node.bufferSize
          const buffer = widget.buffer = [
            new Shared32Array(size),
            new Shared32Array(size)
          ]

          const context = {
            url: editor.filename,
            bpm: node.bpm,
            beatRate: node.beatRate,
            sampleRate: node.sampleRate,
            buffer,
          }

          const fn = widget.fn = c => c.src(editor.filename)

          const mix = widget.mix = Mix(context)
          node.onbar = async () => {
            widget.n += widget.buffer[0].length
            widget.render()
          }
        }

        widget.render = atomic(async () => {
          if (scheduleUpdate.size > 0) {
            for (const url of scheduleUpdate) {
              mixWorker.update(url)
            }
            scheduleUpdate.clear()
          }
          const time = performance.now()
          console.time('audio render')
          try {
            console.log('PASS N', widget.n)
            await widget.mix(widget.fn, { n: widget.n })
            if (!widget.node.playing) return
          } catch (error) {
            errors.textContent = error.stack
            console.timeEnd('audio render')
            console.error(error)
            return
          }
          console.timeEnd('audio render')
          const diff = performance.now() - time
          console.log('time to render:', diff)
          if (diff > 1000) console.warn('Too slow!', (diff/1000).toFixed(1) + 's' )
          widget.node.playBuffer(widget.buffer)
          draw(widget.buffer[0])
        }, { recentOnly: true, timeout: 2000 })

        console.time('audio render ' + widget.buffer[0].length)
        try {
          await widget.mix(widget.fn, { n: widget.n })
          if (type === 'loop' && !playingWidget) return
        } catch (error) {
          errors.textContent = error.stack
          console.timeEnd('audio render ' + widget.buffer[0].length)
          console.error('thrown error', error)
          return
        }
        console.timeEnd('audio render ' + widget.buffer[0].length)

        if (type === 'shot') {
          if (scheduleUpdate.size > 0) {
            for (const url of scheduleUpdate) {
              mixWorker.update(url)
              console.log('updating', url)
            }
            scheduleUpdate.clear()
          }
          widget.node.setBuffer(widget.buffer)
          widget.node.start()

          // const sweepBuffer = [
          //   new Shared32Array(4096)
          // ]
          // const sweep = Mix({ url: editor.filename, buffer: sweepBuffer })
          // await sweep(c => c(
          //   c => {
          //     let freq = Math.floor((((1+c.p) / c.bufferSize) * 22050) / 20) * 20
          //     return (1 - 2 * (c.s % (1 / freq)) * freq)*.3
          //       + Math.sin(freq * c.s * Math.PI * 2)*.3
          //       + (Math.random() * 2 - 1)*.3
          //   },
          //   // + Math.cos(((1+c.p) / c.bufferSize) * 22050 * c.s * Math.PI * 2),
          //   // c => Math.random() * 2 - 1,//Math.sin(((1+c.p) / c.bufferSize) * 22050 * c.s * Math.PI * 2),
          //   c => c.src(editor.filename)
          // ))
          // drawWorker.postMessage({ drawSweep: sweep.buffer[0] })

        } else {
          widget.node.resetTime?.(-3)
          widget.node.start()
          widget.node.playBuffer(widget.buffer)
        }
        draw(widget.buffer[0])
      }

      node.parentNode.replaceChild(div, node)

      editor.onresize()
      setInterval(() => editor.onresize(), 1000)
    })

  scheduleUpdate.clear()

  registerEvents(document.body)

  setTimeout(() => {
    scheduleUpdate.clear()
    document.querySelector('.play').dispatchEvent(new MouseEvent('mousedown'))
  }, 300)
}

const drawWorker = new Worker('/draw-worker.js', { type: 'module' })
const osWaveform = waveform.transferControlToOffscreen()
const osSpectrogram = spectrogram.transferControlToOffscreen()
const osFrequency = frequency.transferControlToOffscreen()

waveform.onclick = () => {
  drawWorker.postMessage({ toggle: 'waveform' })
}

spectrogram.onclick = () => {
  drawWorker.postMessage({ toggle: 'spectrogram' })
}

frequency.onclick = () => {
  drawWorker.postMessage({ toggle: 'frequency' })
}

drawWorker.postMessage({
  waveform: osWaveform,
  spectrogram: osSpectrogram,
  frequency: osFrequency
}, [osWaveform, osSpectrogram, osFrequency])

const draw = (data) => {
  drawWorker.postMessage({ draw: data })
  // drawWaveform(waveform, data)
  // drawSpectrogram(spectrogram, data)
}

main()
</script>
</body>
</html>