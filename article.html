<html>
<head>
<meta charset="utf-8">
<link href="https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400;1,700&family=Work+Sans:ital,wght@0,400;0,500;1,400;1,500&display=swap" rel="stylesheet">
<link rel="stylesheet" href="./article.css">
</head>
<body>
<article>
<!--
<h1>
making a <b>TECHNO</b> track
<br>
from <strong>Scratch</strong>
</h1>

<p>In this article we will work our way to a viable <em>Techno</em> music track, using basic <strong>first principles</strong> and in the process we will learn about subjects like <em>acoustics</em> and <em>psychoacoustics</em>, <em>sound synthesis</em>, <em>rhythmic</em> and <em>harmonic</em> composition and arrangement, <em>mixing techniques</em> and we'll finally produce something that we can <em>dance to</em> and <em>enjoy!</em>
<br>
<br>
And all of this using just coding, and specifically, <strong>JavaScript</strong>.
Feeling intrigued yet? Follow me...</p>

<h2>The Kick</h2>

<p>Every good Techno track starts with a <strong>Kick</strong>. But what <em>is</em> a kick, <em>really?</em> According to Wikipedia:
</p>
<blockquote>
  The bass drum, or kick drum, is a large drum that produces a note of low definite or indefinite pitch
  <br>...<br>
  Bass drums are percussion instruments and vary in size and are used in several musical genres
  <br>...<br>
  In many forms of music, the bass drum is used to mark or keep time. The bass drum makes a low, boom sound when the mallet hits the drumhead.
</blockquote>
<p>
Ok, so what we get from this is that it's a kind of a <em>low-sounding</em> percussion instrument that is used to <em>keep time</em>. That last bit is particularly interesting, keeping time. What <em>is</em> time?</p>

<img src="./what-is-time.png">

<p>Besides being an illusion, you could also say that time is what it takes to get from place A to place B. And how do we get there? We walk! One foot after another. Applying a bit of Aristotelian logic, if thing A can do X and thing B can do the same X, then thing A can possibly be represented by thing B. So, if feet track time, and kicks track time, then feet must be for kicks. And vice versa. So, the kick sound is represented by our feet. Makes sense, that's why it's called a <em>kick</em>. But not only that, actually all sounds are represented on our body. Low frequency sounds like kicks and bass map to the lower part of our body, and higher frequency sounds like snares, hihats and most of the instruments map to our upper body.
</p>
<p>
Ugghh, enough geeking! Let's listen to the damn kick. Click on play:
</p>-->
<!-- <pre><code title="techno-tutorial/kick-simple.js" type="shot" bpm="60">
export default c =>
  Math.sin(440 * 2 * Math.PI * c.s)
</code></pre>
 -->
<pre><code title="techno-tutorial/kick-simple.js" type="shot">
export default c =>
  Math.sin(110 * Math.exp(-c.t * 15))
</code></pre>
<!--<p>
digital audio..
sampling..
fourier transform..
wave shape,
sine wave,
exponent,
time
applying filters..
ears as math processors..-->
<pre><code title="techno-tutorial/kick.js" type="shot">
export default (c, {
  phase = 1.822,
  punch = 105,
  speed = 12.8
} = {}) =>
  Math.sin(
    phase
  + punch
  * Math.exp(-c.t * speed)
  ) * (1-Math.min(1, c.t*8.5))
</code></pre>

<pre><code title="techno-tutorial/hihat-inline-hp.js" type="shot">
export default c => c(
  c => Math.sin(Math.random() * Math.exp(-c.t*10)),
  async c => {
    let xm1 = 0
    let x = 0
    let y = 0
    return (c, { a = .5 }) => {
      x = +c.input
      y = (y + x - xm1) * a
      xm1 = x
      return y
    }
  }
)
</code></pre>

<pre><code title="techno-tutorial/highpass.js" type="shot">
export default async c => {
  let xm1 = 0
  let x = 0
  let y = 0
  return (c, { a = .5 }) => {
    x = +c.input
    y = (y + x - xm1) * a
    xm1 = x
    return y
  }
}
</code></pre>

<pre><code title="techno-tutorial/hihat-mixed.js" type="shot">
import Highpass from './highpass.js'
export default c => c(
  c => Math.sin(Math.random() * Math.exp(-c.t*10)),
  async c => {
    const hp = await Highpass(c)
    return c => hp(c, { a: .5 * Math.exp(-c.t*10) })
  }
)
</code></pre>

<pre><code title="techno-tutorial/envelope.js" type="shot">
export default (c, { decay = 10 }) =>
  Math.exp(-c.k * decay)
</code></pre>

<pre><code title="techno-tutorial/hihat.js" type="shot">
import env from './envelope.js'
import Highpass from './highpass.js'
export default c => c(
  c => Math.sin(Math.random() * env(c, { decay: 8 })),
  async c => {
    const hp = await Highpass(c)
    return c => hp(c, { a: .5 * env(c, { decay: 8 }) })
  }
)
</code></pre>

<pre><code title="techno-tutorial/kick-import.js" type="shot">
import kick from './kick.js'
export default c => kick(c)
</code></pre>

<!-- <pre><code title="techno-tutorial/kick-loop-buffer.js" type="loop">
export default async c => {
  const kick = c.render('kick.js')
  return t => kick(t)
}
</code></pre>
 -->
<pre><code title="techno-tutorial/saw.js" type="loop">
export default (c, { freq = 50 }) =>
  1 - 2 * (c.s % (1 / freq)) * freq
</code></pre>

<pre><code title="techno-tutorial/saw-melody.js" type="loop">
import saw from './saw.js'
export default (c, {
  melody = [50, 50, 80, 60]
} = {}) =>
  saw(c, { freq: melody[c.k % melody.length | 0] })
</code></pre>

<pre><code title="techno-tutorial/bass.js" type="loop">
import osc from './saw-melody.js'
export default async c => {
  const filter = c.RingBuffer('filter', 2)

  // lowpass cutoff coefficient generator
  const lowpass = (
    hz,
    dt = 1 / c.sampleRate,
    rc = 1 / (hz * 2 * Math.PI)
  ) => dt / (rc + dt)

  // lowpass filter cutoff frequency
  return mix => mix(
    t => osc(t, { melody: [50, 50, 70, 60] }) * .55,

    // lowpass filter
    (t, {
      cutoff = 300, // lowpass cutoff frequency
      lfoSpeed = 2/3, // lfo speed
      lfoAmount = cutoff - 50, // lfo amount
      lfoPhase = 3.3 // lfo phase
    } = {}) =>
      filter[0] += (t.input - filter[0])
    * lowpass(
        cutoff
      + lfoAmount
      * Math.sin(lfoPhase + lfoSpeed * t.k * Math.PI * 2)
    ),

    // envelope
    t => t.input *
      ( Math.min(1, (t.k%(1/2)) * 20) // attack
      - Math.min(1, (t.k%(1/2)) * 2) // decay
      ),
  )
}
</code></pre>

<pre><code title="techno-tutorial/mix-buffers.js" type="loop" bpm="135">
export default async c => [
  c => 0,
  c => c(
    './hihat.js',
    c => c.buffer[0][c.p % (c.beatRate/2|0)]
  ),
  c => c(
    './kick.js',
    c => c.buffer[0][c.p % c.beatRate]
  )
]
</code></pre>

<pre><code title="techno-tutorial/mix-breaks.js" type="loop">
export default async c => {
  const bass = c.render('bass.js')
  const kick = c.render('kick.js')
  return t =>
    bass(t, { size: c.beatRate*(t.k/4%3<2?3/2:4) })*4
  + kick(t, { size: c.beatRate*(t.k/4%8<7?1:3/2) })*6
}
</code></pre>

</article>
<script type="module">
import Editor, { registerEvents } from './src/editor.js'
import LoopNode from './vendor/dsp/src/loop-node.js'
import ShotNode from './vendor/dsp/src/shot-node.js'
import Mix from './vendor/dsp/src/mix.js'
import DynamicCache from './vendor/dsp/dynamic-cache.js'
import toFinite from './lib/to-finite.js'
import Audio from './audio.js'

const app = {}

const main = async () => {
  await DynamicCache.install()
  const cache = new DynamicCache('article', { 'Content-Type': 'application/javascript' })

  const widgets = []

  cache.onchange = url => {
    console.log('changed', url)
    widgets.forEach(async widget => {
      console.log(widget.mix?.g?.loaders)
      if (widget.mix?.g?.loaders?.[url]) {
        delete widget.mix.g.loaders[url]
        // if (widget.node.playing) {

          // const promise = new Promise(resolve => widget.mix.g.onload = resolve)
          // widget.mix(widget.fn)
          // await promise
          // await widget.mix(widget.fn)
          // widget.node.setBuffer(widget.buffer)

        // }

        console.log('updateddddddddddddddd', url)
      }
    })
  }

  const PlayNode = {
    'loop': LoopNode,
    'shot': ShotNode
  }

  const PlayIcon = {
    'loop': '⟲',
    'shot': '▶',
    'playing': '𝄥'
  }

  ;[...document.querySelectorAll('code')].forEach(
    (node, i) => {
      const widget = {}

      widgets.push(widget)

      const type = widget.type = node.getAttribute('type')
      const bpm = widget.bpm = toFinite(+node.getAttribute('bpm')) || 60

      const editor = widget.editor = new Editor({
        id: i,
        title: node.title,
        value: node.textContent.trim(),
        fontSize: '11.5pt',
        width: 620,
        height: 1,
        padding: 10,
        autoResize: true,
        pseudoWorker: true,
        cache
      })

      const div = document.createElement('div')
      div.className = 'editor'
      div.appendChild(editor.canvas)

      const play = document.createElement('div')
      play.className = 'play ' + type
      play.textContent = PlayIcon[type]
      play.style.zIndex = '1000'
      div.appendChild(play)

      const errors = document.createElement('div')
      errors.className = 'errors'
      div.appendChild(errors)

      play.onmousedown = async () => {
        const audio = Audio()

        if (widget.node?.playing) {
          widget.node.stop(0)
          play.classList.remove('playing')
          play.textContent = PlayIcon[type]
          console.log('should stop????????????')
          return
        }

        if (widget.type === 'loop') {
          play.classList.add('playing')
          play.textContent = PlayIcon['playing']
        }

        // errors.textContent = ''

        if (!widget.node) {
          const node = widget.node = new PlayNode[type]
          node.setBpm(widget.bpm)
          node.connect(audio.gain)

          const buffer = widget.buffer = [
            new Float32Array(node.bufferSize),
            new Float32Array(node.bufferSize)
          ]

          const context = {
            bpm: node.bpm,
            beatRate: node.beatRate,
            sampleRate: node.sampleRate,
            buffer,
          }

          const fn = widget.fn = async c => [
            c => 0,
            editor.filename
          ]

          const mix = widget.mix = Mix(context)
          node.onbar = async () => {
            console.log('bar')
            await widget.mix(widget.fn)
            widget.node.setBuffer(widget.buffer)
          }
        }

        widget.node.start()

        // const promise = new Promise(resolve => widget.mix.g.onload = resolve)
        await widget.mix(widget.fn)
        widget.node.setBuffer(widget.buffer)
        // await promise
        // await widget.mix(widget.fn)
        // // .render(editor.filename, { type: c.type })

        // mix.onerror = e => {
        //   errors.textContent = e.stack.replaceAll(
        //     document.location.origin + cache.path + '/',
        //     ''
        //   ) //.split('\n').slice(0, 3).join('\n')
        // }

        // mix.onchange = () => {
        //   errors.textContent = ''
        //   // editor?.bufferSourceNode?.stop(editor.syncTime)
        // }

        // mix.onrender = () => {
        // }


        // // const filename = await cache.put(editor.title, editor.value)
        // const render = workerMix(editor.filename)
        // render.onerror = e => {
        //   errors.textContent = e.stack.replaceAll(
        //     document.location.origin + cache.path + '/',
        //     ''
        //   ) //.split('\n').slice(0, 3).join('\n')
        // }
        // render.onchange = () => {
        //   errors.textContent = ''
        //   // editor?.bufferSourceNode?.stop(editor.syncTime)
        // }
        // render.onrender = () => {
        //   if (!isPlaying) return

        //   const audioBuffer = editor.audioBuffer =
        //     app.audio.createBuffer(
        //       2,
        //       bufferSize,
        //       app.audio.sampleRate
        //     )

        //   const bufferSourceNode = app.audio.createBufferSource()
        //   bufferSourceNode.buffer = audioBuffer
        //   bufferSourceNode.connect(app.gain)
        //   bufferSourceNode.loop = isLoop

        //   for (const [i, data] of buffer.entries()) {
        //     audioBuffer.getChannelData(i).set(data)
        //   }

        //   // const beatTime = context.beatRate / context.sampleRate
        //   const barTime = (context.beatRate * 4) / context.sampleRate
        //   const time = app.audio.currentTime
        //   const remainTime = barTime - (time % barTime)
        //   const syncTime = type === 'loop' ? time + remainTime : 0


        //   if (editor.bufferSourceNode) {
        //     schedulePlay = true

        //     // console.log('should stop at', syncTime)
        //     editor.bufferSourceNode.onended = () => {
        //       if (isPlaying && type === 'loop') render(context)
        //     }
        //     editor.bufferSourceNode.stop(syncTime)
        //     // return
        //   }
        //   editor.bufferSourceNode = bufferSourceNode
        //   // console.log('should start at', syncTime)
        //   bufferSourceNode.start(syncTime)
        //   if (type === 'shot') bufferSourceNode.onended = stop
        //   if (type !== 'shot' && !schedulePlay) render(context)
        // }

        // render(context)
      }

      node.parentNode.replaceChild(div, node)

      editor.onresize()
      setInterval(() => editor.onresize(), 1000)
    })

  registerEvents(document.body)
}

main()
</script>
</body>
</html>